
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>PGR-TK &#8212; pgr-tk  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to PGR-TK’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="pgr-tk">
<h1>PGR-TK<a class="headerlink" href="#pgr-tk" title="Permalink to this heading">¶</a></h1>
<p>PGR-TK provide Python and Rust libraries to facilitate pangenomics analysis. Several algorithms and data structures used for the Peregrine Genome Assembler are useful for Pangenomics analysis. This repo takes those algorithms and data structure, combining other handy 3rd party tools to expose them as a library in Python (with Rust code for those computing parts that need performance.)</p>
<section id="module-contents">
<h2>Module contents<a class="headerlink" href="#module-contents" title="Permalink to this heading">¶</a></h2>
<section id="module-pgrtk">
<span id="pgrtk"></span><h3>pgrtk<a class="headerlink" href="#module-pgrtk" title="Permalink to this heading">¶</a></h3>
<p>This module is used to extract and compare sequences in a set of pan genome assemblies.
It includes a number modules for access the sequence data and query the sequence index.</p>
<p class="rubric">Example</p>
<p>This shows a simple example to query the pangenome database:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pgrtk</span>

<span class="c1">## The AGCFile class is used to access the sequence data stored in a AGC file.</span>
<span class="n">ref_db</span> <span class="o">=</span><span class="n">pgrtk</span><span class="o">.</span><span class="n">AGCFile</span><span class="p">(</span><span class="s2">&quot;hg19.agc&quot;</span><span class="p">)</span>

<span class="c1">## Load a pre-build index and sequence data from all humane genome assemblies</span>
<span class="c1">## of the HPRC year one release.</span>
<span class="n">sdb</span> <span class="o">=</span> <span class="n">pgrtk</span><span class="o">.</span><span class="n">SeqIndexDB</span><span class="p">()</span>
<span class="n">sdb</span><span class="o">.</span><span class="n">load_from_agc_index</span><span class="p">(</span><span class="s2">&quot;HPRC-y1-rebuild-04252022&quot;</span><span class="p">)</span>

<span class="c1">## Extract a sequence from the hg19 AGC file.</span>
<span class="n">gene_seq</span> <span class="o">=</span> <span class="n">ref_db</span><span class="o">.</span><span class="n">get_sub_seq</span><span class="p">(</span><span class="s1">&#39;hg19.fasta&#39;</span><span class="p">,</span> <span class="s1">&#39;chr6&#39;</span><span class="p">,</span>
                              <span class="mi">160952514</span><span class="p">,</span> <span class="mi">161087407</span><span class="p">)</span>

<span class="c1">## find hits in the pangenomic reference</span>
<span class="n">alignment_ranges</span> <span class="o">=</span> <span class="n">pgrtk</span><span class="o">.</span><span class="n">query_sdb</span><span class="p">(</span><span class="n">sdb</span><span class="p">,</span> <span class="n">gene_seq</span><span class="p">,</span>
                                     <span class="n">merge_range_tol</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.compute_graph_diffusion_entropy">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">compute_graph_diffusion_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gfa_fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.compute_graph_diffusion_entropy" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Give a GFA file name, compute an entropy by a simple diffusion model on the grap</dt><dd><p>and generate the list of the final diffusion weight for each node</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>gfa_fn</strong> (<em>string</em>) – a gfa filename</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><code class="docutils literal notranslate"><span class="pre">(entropy,</span> <span class="pre">list_of_diffusion_weight)</span></code></p>
<p>list_of_diffusion_weight = <code class="docutils literal notranslate"><span class="pre">[(node_id,</span> <span class="pre">weight),</span> <span class="pre">...]</span></code></p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.get_principle_bundle_bed_file_for_query">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">get_principle_bundle_bed_file_for_query</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">56</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_branch_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.get_principle_bundle_bed_file_for_query" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.get_variant_calls">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">get_variant_calls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aln_segs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_bgn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctg_bgn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rs0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cs0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strand</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.get_variant_calls" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a variant call internal representation from the alignment segments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aln_segs</strong> (<em>list</em><em> of </em><em>tuples</em>) – <ul>
<li><p>a list of tuples of “alignment segments” generate by <code class="docutils literal notranslate"><span class="pre">pgrtk.pgrtk.get_aln_segments()</span></code></p></li>
<li><p>the “alignment segments” are a list of <code class="docutils literal notranslate"><span class="pre">(ref_loc:</span> <span class="pre">SeqLocus,</span> <span class="pre">tgt_loc:</span> <span class="pre">SeqLocus,</span> <span class="pre">align_type:</span> <span class="pre">AlnSegType)</span></code>. The data structures
is defined as following Rust structs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pub</span> <span class="n">struct</span> <span class="n">SeqLocus</span> <span class="p">{</span>
    <span class="n">pub</span> <span class="nb">id</span><span class="p">:</span> <span class="n">u32</span><span class="p">,</span>
    <span class="n">pub</span> <span class="n">bgn</span><span class="p">:</span> <span class="n">u32</span><span class="p">,</span>
    <span class="n">pub</span> <span class="nb">len</span><span class="p">:</span> <span class="n">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">pub</span> <span class="n">enum</span> <span class="n">AlnSegType</span> <span class="p">{</span>
    <span class="n">Match</span><span class="p">,</span>
    <span class="n">Mismatch</span><span class="p">,</span>
    <span class="n">Insertion</span><span class="p">,</span>
    <span class="n">Deletion</span><span class="p">,</span>
    <span class="n">Unspecified</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">pub</span> <span class="n">struct</span> <span class="n">AlnSegment</span> <span class="p">{</span>
    <span class="n">pub</span> <span class="n">ref_loc</span><span class="p">:</span> <span class="n">SeqLocus</span><span class="p">,</span>
    <span class="n">pub</span> <span class="n">tgt_loc</span><span class="p">:</span> <span class="n">SeqLocus</span><span class="p">,</span>
    <span class="n">pub</span> <span class="n">t</span><span class="p">:</span> <span class="n">AlnSegType</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</p></li>
<li><p><strong>ref_bgn</strong> (<em>int</em>) – the reference sequence start position</p></li>
<li><p><strong>ctg_bgn</strong> (<em>int</em>) – the contig start position</p></li>
<li><p><strong>rs0</strong> (<em>string</em>) – the reference sequence</p></li>
<li><p><strong>cs0</strong> (<em>string</em>) – the contig sequence</p></li>
<li><p><strong>strand</strong> (<em>int</em>) – the contig strand</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a dictionary mapping the key (ref_id, reference_position) to a set of variant
calls in the form of a dictionary mapping from (target_location, strand) to
a variant call record.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.group_smps_by_principle_bundle_id">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">group_smps_by_principle_bundle_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">smps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">len_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.group_smps_by_principle_bundle_id" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Filter and group SHIMMER pair output from SeqIndexDB.get_principal_bundle_decomposition()</dt><dd><p>by bundle id. This function will filter out small bundle segment with lenght smaller than
<cite>len_curoff</cite> and merge two bundle with the same id and direction within <cite>merge_length</cite></p>
<p>TODO: This is currently implemented in python, we plan to move this as
Rust code in the future.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>len_cutoff</strong> (<em>int</em>) – the length cutoff used for filtering small bundle segment</p></li>
<li><p><strong>merge_length</strong> (<em>int</em>) – the length determining if two bundles should be merged</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>a list of the lists of SHIMMER pairs tagged with bundle id, direction, position in the bundle</p>
<p>each element of the list SHIMMER is a tuple of
<cite>((shimmer0, shimmer1, pos0, pos1, direction),
bundle_id, direction_to_the_bundle, position_in bundle)</cite></p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.map_intervals_in_sdb">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">map_intervals_in_sdb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_index_db</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query_seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_penality_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_range_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_query_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_target_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_aln_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.map_intervals_in_sdb" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: Document</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.merge_regions">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">merge_regions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.merge_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a list of ranges and merge them if two regions are within <code class="docutils literal notranslate"><span class="pre">tol</span></code>.
:param rgns: a list of tuples of (<code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">length</span></code>, <code class="docutils literal notranslate"><span class="pre">orientation</span></code>, …)
:type rgns: list of tuples</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of tuples of (<code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">length</span></code>, <code class="docutils literal notranslate"><span class="pre">orientation</span></code>, …)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list of tuples</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.output_variants_to_vcf_records">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">output_variants_to_vcf_records</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variant_calls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.output_variants_to_vcf_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the variant calls to VCF records.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variant_calls</strong> (<em>dict</em>) – the variant calls generated by <code class="docutils literal notranslate"><span class="pre">get_variant_calls()</span></code></p></li>
<li><p><strong>ref_name</strong> (<em>string</em>) – reference sequence name</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of VCF records</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.query_sdb">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">query_sdb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_index_db</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query_seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gap_penalty_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_range_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_query_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_target_count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_aln_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.query_sdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Query a sequence index database for a query sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_index_db</strong> (<em>SeqIndexDB object</em>) – a sequence index database object</p></li>
<li><p><strong>query_seq</strong> (<em>list</em><em> of </em><em>bytes</em>) – a list of bytes representing the DNA sequence</p></li>
<li><p><strong>gap_penalty_factor</strong> (<em>float</em>) – the gap penalty factor used in sparse dynamic programming for finding the hits</p></li>
<li><p><strong>merge_range_tol</strong> (<em>int</em>) – a parameter used to merge the alignment ranges</p></li>
<li><p><strong>max_count</strong> (<em>int</em>) – only use the shimmer pairs that less than the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> for sparse dynamic programming</p></li>
<li><p><strong>max_query_count</strong> (<em>int</em>) – only use the shimmer pairs that less than the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> in the query sequence for sparse dynamic programming</p></li>
<li><p><strong>max_query_count</strong> – only use the shimmer pairs that less than the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> in the target sequence for sparse dynamic programming</p></li>
<li><p><strong>max_aln_span</strong> (<em>int</em>) – the size of span used in the sparse dynamic alignment for finding the hits</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>a python dictionary with the key as the target sequence id and the value as a list of alignment ranges</p></li>
<li><p>each alignment ranges is a list of tuples, each tuple is (<code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">length</span></code>,
<code class="docutils literal notranslate"><span class="pre">orientation</span></code>, <code class="docutils literal notranslate"><span class="pre">aln_records</span></code>)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">aln_records</span></code> is a list of tuples of
(<code class="docutils literal notranslate"><span class="pre">target_sequence_id</span></code>, (<code class="docutils literal notranslate"><span class="pre">score</span></code>, <code class="docutils literal notranslate"><span class="pre">list_of_the_hit_pairs</span></code>)), where
the <code class="docutils literal notranslate"><span class="pre">list_of_the_hit_pairs</span></code> is a list of tuples of
((<code class="docutils literal notranslate"><span class="pre">query_start</span></code>, <code class="docutils literal notranslate"><span class="pre">query_end</span></code>, <code class="docutils literal notranslate"><span class="pre">query_orientation</span></code>),
(<code class="docutils literal notranslate"><span class="pre">target_start</span></code>, <code class="docutils literal notranslate"><span class="pre">target_end</span></code>, <code class="docutils literal notranslate"><span class="pre">target_orientation</span></code>))</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.rc">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">rc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.rc" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse complement a sequence as a Python String.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seq</strong> (<em>string</em>) – a DNA sequence as a Python String</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the reverse complement DNA sequence as a Python String</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.rc_byte_seq">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">rc_byte_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.rc_byte_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse complement a sequence as a list of bytes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seq</strong> (<em>list</em><em> of </em><em>bytes</em>) – ascii code of the DNA sequence</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the list of bytes of the reverse complement DNA sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.rc_u8_seq">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">rc_u8_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.rc_u8_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse complement a sequence as a list of bytes (unsigned 8bit interger).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seq</strong> (<em>list</em><em> of </em><em>bytes / usigned 8bit interger</em>) – ascii code of the DNA sequence</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the list of bytes of the reverse complement DNA sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.string_to_u8">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">string_to_u8</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.string_to_u8" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Python String to a list of bytes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>s</strong> (<em>string</em>) – a Python String of a DNA sequence</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of bytes representing the DNA sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of bytes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.u8_to_string">
<span class="sig-prename descclassname"><span class="pre">pgrtk.</span></span><span class="sig-name descname"><span class="pre">u8_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.u8_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert DNA sequene in a list of bytes to a Python String.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>u8</strong> (<em>list</em><em> of </em><em>bytes</em>) – a list of bytes representing the DNA sequence</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a Python String of a DNA sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pgrtk.pgrtk">
<span id="pgrtk-pgrtk"></span><h3>pgrtk.pgrtk<a class="headerlink" href="#module-pgrtk.pgrtk" title="Permalink to this heading">¶</a></h3>
<p>The internal <cite>pgrtk</cite> modules implemented with Rust.
These classes and fucntion are re-exported as <cite>pgrtk.*</cite>
so <cite>import pgrtk</cite> will bring these classes and function
into <cite>pgrtk.*</cite> scope to avoid using the verbose
<cite>pgrtk.pgrtk.*</cite>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pgrtk.pgrtk.AGCFile">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">AGCFile</span></span><a class="headerlink" href="#pgrtk.pgrtk.AGCFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A PyO3 class wrapping an existing AGC file for reading</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">agc_file</span> <span class="o">=</span> <span class="n">AGCFile</span><span class="p">(</span><span class="s2">&quot;/path/to/genomes.agc&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="pgrtk.pgrtk.AGCFile.ctg_lens">
<span class="sig-name descname"><span class="pre">ctg_lens</span></span><a class="headerlink" href="#pgrtk.pgrtk.AGCFile.ctg_lens" title="Permalink to this definition">¶</a></dt>
<dd><p>A hashmap mapping (source, ctg_name) to sequence length.
It is more efficient to make a copy in Python to access it to avoid
expensive Rust struct ot Python object conversion than using it directly. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">agc_file</span> <span class="o">=</span> <span class="n">AGCFile</span><span class="p">(</span><span class="s2">&quot;genomes.agc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">agc_ctg_lens</span> <span class="o">=</span> <span class="n">agc_file</span><span class="o">.</span><span class="n">ctg_lens</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.AGCFile.get_seq">
<span class="sig-name descname"><span class="pre">get_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctg_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.AGCFile.get_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch a full contig sequence from an AGC file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_name</strong> (<em>string</em>) – the sample name stored in the AGC file</p></li>
<li><p><strong>ctg_name</strong> (<em>string</em>) – the contig name stored in the AGC file</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of bytes representing the sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.AGCFile.get_sub_seq">
<span class="sig-name descname"><span class="pre">get_sub_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctg_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.AGCFile.get_sub_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch a contiguous sub-sequence from an AGC file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_name</strong> (<em>string</em>) – the sample name stored in the AGC file</p></li>
<li><p><strong>ctg_name</strong> (<em>string</em>) – the contig name stored in the AGC file</p></li>
<li><p><strong>bgn</strong> (<em>int</em>) – the starting coordinate (0-based)</p></li>
<li><p><strong>end</strong> (<em>int</em>) – the ending coordinate (exclusive)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of bytes representing the sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">SeqIndexDB</span></span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class that stores pangenome indices and sequences with multiple backend storage options (AGC, fasta file, memory)
Large set of genomic sequences, a user should use AGC backend. A binary file provides the command <code class="docutils literal notranslate"><span class="pre">pgr-mdb</span></code>
which can read an AGC to create the index file. For example, we can create the index files from an AGC file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># create a file that contains a list of file that contains a set of files from which we want to build the indices

$ echo HPRC-y1-rebuild-04252022.agc &gt; filelist

# using pgr-mdb to create the index files, for 97 haplotyped genome assembly from HPRC year one release,
# it takes about 30 to 40 min to create the index files

$ pgr-mdb filelist HPRC-y1-rebuild-04252022

# two index files will be created by the pgr-mdb command
# one with a suffix .mdb and another one with a suffix .midx
# when we use the load_from_agc_index() method, all three files, e.g., genomes.agc, genomes.mdb and
# genomes.midx should have the same prefix as the parameter used to call  load_from_agc_index() method
</pre></div>
</div>
<p>One can also create index and load the sequences from a fasta file using <code class="docutils literal notranslate"><span class="pre">`load_from_fastx()`</span></code> methods.
Currently, this might be a good option for mid-size dataset (up to a couple of hundred megabases).</p>
<p>Or, a user can load the sequence from memory using a Python list. This is convenient when one needs to
rebuild the SHIMMER index with different parameters for a different resolution.</p>
<p>Once the index is built, the database can be queried quickly by using the <code class="docutils literal notranslate"><span class="pre">query_fragment()</span></code> or
the <code class="docutils literal notranslate"><span class="pre">query_fragment_to_hps()</span></code> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.append_from_fastx">
<span class="sig-name descname"><span class="pre">append_from_fastx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.append_from_fastx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.generate_mapg_gfa">
<span class="sig-name descname"><span class="pre">generate_mapg_gfa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keeps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.generate_mapg_gfa" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the adjacent list of the shimmer graph shimmer_pair -&gt; GFA</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_count</strong> (<em>int</em>) – the minimum number of times a pair of shimmers must be observed to be included in the graph</p></li>
<li><p><strong>filepath</strong> (<em>string</em>) – the path to the output file</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The data is written into the file at filepath</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.generate_principal_mapg_gfa">
<span class="sig-name descname"><span class="pre">generate_principal_mapg_gfa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_len_cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keeps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.generate_principal_mapg_gfa" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the adjacent list of the shimmer graph shimmer_pair -&gt; GFA</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_count</strong> (<em>int</em>) – the minimum number of times a pair of shimmers must be observed to be included in the graph</p></li>
<li><p><strong>filepath</strong> (<em>string</em>) – the path to the output file</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The data is written into the file at filepath</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_match_positions_with_fragment">
<span class="sig-name descname"><span class="pre">get_match_positions_with_fragment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_match_positions_with_fragment" title="Permalink to this definition">¶</a></dt>
<dd><p>use a fragment of sequence to query the database to get all hits and sort it by the data base sequence id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seq</strong> (<em>list</em>) – the sequence in bytes used for query</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a dictionary maps sequence id in the database to a list of tuple (position0, position1, direction)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_principal_bundle_decomposition">
<span class="sig-name descname"><span class="pre">get_principal_bundle_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_len_cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keeps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_principal_bundle_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the principal bundles and bundle decomposition of all sequences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_count</strong> (<em>int</em>) – minimum coverage count to be included in the graph</p></li>
<li><p><strong>path_len_cut_off</strong> (<em>int</em>) – <p>remove short path less than path_len_cut_off when generating the principal path</p>
<p>if the number is small, the generated principal paths will be more fragmented.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>a tuple consist of two lists: (principal_bundles, seqid_smps_with_bundle_id_seg_direction)</p>
<p>principal_bundles = list of (principal_bundle_id, ave_bundle_position, list_bundle_vertex)</p>
<p>list_of_bundle_vertex = list of (hash0:u64, hash0:u64, direction:u8)</p>
<p>seqid_smps_with_bundle_id_seg_direction = list of shimmer pairs in the database annotated with principal bundle id and direction</p>
<dl class="simple">
<dt>the elements of the list are ((hash0:u64, hash1:u64, pos0:u32, pos0:u32, direction:0),</dt><dd><p>(principal_bundle_id, direction, order_in_the_bundle))</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_principal_bundle_projection">
<span class="sig-name descname"><span class="pre">get_principal_bundle_projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_len_cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keeps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_principal_bundle_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Project sequences outside the sequence database on to a principal bundle decomposition</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_count</strong> (<em>int</em>) – minimum coverage count to be included in the graph</p></li>
<li><p><strong>path_len_cut_off</strong> (<em>int</em>) – <p>remove short path less than path_len_cut_off when generating the principal path</p>
<p>if the number is small, the generated principal paths will be more fragmented.</p>
</p></li>
<li><p><strong>sequences</strong> (<em>(</em><em>contig_id: int</em><em>, </em><em>list</em><em> of </em><em>sequences</em><em>)</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>a tuple consist of two lists: (principal_bundles, seqid_smps_with_bundle_id_seg_direction)</p>
<p>principal_bundles = list of (principal_bundle_id, ave_bundle_position, list_bundle_vertex)</p>
<p>list_of_bundle_vertex = list of (hash0:u64, hash0:u64, direction:u8)</p>
<p>seqid_smps_with_bundle_id_seg_direction = list of shimmer pairs in the database annotated with principal bundle id and direction</p>
<dl class="simple">
<dt>the elements of the list are ((hash0:u64, hash1:u64, pos0:u32, pos0:u32, direction:0),</dt><dd><p>(principal_bundle_id, direction, order_in_the_bundle))</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_principal_bundles">
<span class="sig-name descname"><span class="pre">get_principal_bundles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_len_cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keeps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_principal_bundles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the principal bundles in MAPG</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_count</strong> (<em>int</em>) – minimum coverage count to be included in the graph</p></li>
<li><p><strong>path_len_cut_off</strong> (<em>int</em>) – <p>remove short path less than path_len_cut_off when generating the principal path</p>
<p>if the number is small, the generated principal paths will be more fragmented.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of paths, each path is a list of nodes</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_seq">
<span class="sig-name descname"><span class="pre">get_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctg_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch a sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_name</strong> (<em>string</em>) – the sample name stored in the AGC file</p></li>
<li><p><strong>ctg_name</strong> (<em>string</em>) – the contig name stored in the AGC file</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of bytes representing the sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_seq_by_id">
<span class="sig-name descname"><span class="pre">get_seq_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctg_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_seq_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch a sequence by the sequence id in the database</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sid</strong> (<em>int</em>) – sequence id in the database</p></li>
<li><p><strong>ctg_name</strong> (<em>string</em>) – the contig name stored in the AGC file</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of bytes representing the sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_shmmr_map">
<span class="sig-name descname"><span class="pre">get_shmmr_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_shmmr_map" title="Permalink to this definition">¶</a></dt>
<dd><p>get the <code class="docutils literal notranslate"><span class="pre">shmmr_pair</span></code> to <code class="docutils literal notranslate"><span class="pre">fragment_id</span></code> map in Python</p>
<p>this can be very expensive to generate the Python objects of a large hashmap in Rust</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>the <code class="docutils literal notranslate"><span class="pre">shmmr_pair</span></code> to <code class="docutils literal notranslate"><span class="pre">fragments</span></code> map</p>
<p>fragments: a list of <code class="docutils literal notranslate"><span class="pre">FragmentSignature</span></code>: (frg_id, seq_id, bgn, end,
orientation(to the shimmer pair)) defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pub</span> <span class="nb">type</span> <span class="n">FragmentSignature</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
</pre></div>
</div>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_shmmr_pair_count">
<span class="sig-name descname"><span class="pre">get_shmmr_pair_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shmmr_pair</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_shmmr_pair_count" title="Permalink to this definition">¶</a></dt>
<dd><p>count the number of shimmer hits in the database</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>shmmr_pair</strong> (<em>tuple</em>) – a shimmer pair used for query</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>number of hits</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_shmmr_pair_list">
<span class="sig-name descname"><span class="pre">get_shmmr_pair_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_shmmr_pair_list" title="Permalink to this definition">¶</a></dt>
<dd><p>get the <code class="docutils literal notranslate"><span class="pre">shmmr_pair</span></code> to <code class="docutils literal notranslate"><span class="pre">fragment_id</span></code> map in Python as a list</p>
<p>this can be very expensive to generate the Python objects of a large hashmap in Rust</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of the tuple (shmmr0, shmmr1, seq_id, position0, position1, orientation)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_shmmr_pair_source_count">
<span class="sig-name descname"><span class="pre">get_shmmr_pair_source_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shmmr_pair</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_unique_count</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_shmmr_pair_source_count" title="Permalink to this definition">¶</a></dt>
<dd><p>count the number of shimmer hits partitioned by the source file in the database</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shmmr_pair</strong> (<em>tuple</em>) – a shimmer pair used for query</p></li>
<li><p><strong>max_unique_count</strong> (<em>int</em>) – a integer to filter out shimmer pairs with count that are greater
than the <cite>max_unique_count</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of the tuple (source_name : string, count : int)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_shmmr_spec">
<span class="sig-name descname"><span class="pre">get_shmmr_spec</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_shmmr_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Output the specific of the shimmer used to build the index</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(window_size, k_mer_size, reduction_factor, min_space, use_sketch)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_smp_adj_list">
<span class="sig-name descname"><span class="pre">get_smp_adj_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keeps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_smp_adj_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get adjacent list of the shimmer graph shimmer_pair -&gt; shimmer_pair</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>min_count</strong> (<em>int</em>) – the minimum number of times a pair of shimmers must be observed to be included in the graph</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of pairs of shimmer pairs ((h00, h01, orientation0),(h10, h11, orientation1))</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_sub_seq">
<span class="sig-name descname"><span class="pre">get_sub_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctg_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_sub_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch a contiguous sub-sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_name</strong> (<em>string</em>) – the sample name stored in the AGC file</p></li>
<li><p><strong>ctg_name</strong> (<em>string</em>) – the contig name stored in the AGC file</p></li>
<li><p><strong>bgn</strong> (<em>int</em>) – the starting coordinate (0-based)</p></li>
<li><p><strong>end</strong> (<em>int</em>) – the ending coordinate (exclusive)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of bytes representing the sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_sub_seq_by_id">
<span class="sig-name descname"><span class="pre">get_sub_seq_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctg_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_sub_seq_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch a contiguous sub-sequence by a sequence id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sid</strong> (<em>int</em>) – sequence id in the database</p></li>
<li><p><strong>bgn</strong> (<em>int</em>) – the starting coordinate (0-based)</p></li>
<li><p><strong>end</strong> (<em>int</em>) – the ending coordinate (exclusive)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of bytes representing the sequence</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.get_vertex_map_from_principal_bundles">
<span class="sig-name descname"><span class="pre">get_vertex_map_from_principal_bundles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.get_vertex_map_from_principal_bundles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.load_from_agc_index">
<span class="sig-name descname"><span class="pre">load_from_agc_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.load_from_agc_index" title="Permalink to this definition">¶</a></dt>
<dd><p>use AGC file for sequences and the index created from an AGC file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prefix</strong> (<em>string</em>) – the prefix to the <cite>.agc</cite>, <cite>.mdb</cite> and <cite>.midx</cite> files</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None or I/O Error</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.load_from_fastx">
<span class="sig-name descname"><span class="pre">load_from_fastx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.load_from_fastx" title="Permalink to this definition">¶</a></dt>
<dd><p>load and create the index created from a fasta / fastq file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filepath</strong> (<em>string</em>) – the path the fasta or fastq file</p></li>
<li><p><strong>w</strong> (<em>int</em>) – the window size of the shimmer index, default to 80</p></li>
<li><p><strong>k</strong> (<em>int</em>) – the k-mer size of the shimmer index, default to 56</p></li>
<li><p><strong>r</strong> (<em>int</em>) – the reduction factor of the shimmer index, default to 4</p></li>
<li><p><strong>min_span</strong> (<em>int</em>) – the min_span ofr the shimmer index, default to 8</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None or I/O Error</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.load_from_frg_index">
<span class="sig-name descname"><span class="pre">load_from_frg_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.load_from_frg_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.load_from_seq_list">
<span class="sig-name descname"><span class="pre">load_from_seq_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.load_from_seq_list" title="Permalink to this definition">¶</a></dt>
<dd><p>load and create the index created from a python list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq_list</strong> (<em>list</em>) – a list of tuple of the form (sequence_id : int, sequence_name : string, sequence: list of bytes)</p></li>
<li><p><strong>source</strong> (<em>string</em>) – a string indicating the source of the sequence, default to “Memory”</p></li>
<li><p><strong>w</strong> (<em>int</em>) – the window size of the shimmer index, default to 80</p></li>
<li><p><strong>k</strong> (<em>int</em>) – the k-mer size of the shimmer index, default to 56</p></li>
<li><p><strong>r</strong> (<em>int</em>) – the reduction factor of the shimmer index, default to 4</p></li>
<li><p><strong>min_span</strong> (<em>int</em>) – the min_span ofr the shimmer index, default to 8</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None or I/O Error</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.map_positions_in_seq">
<span class="sig-name descname"><span class="pre">map_positions_in_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">penalty</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_query_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_target_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_aln_span</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.map_positions_in_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence context, this function maps the specific positions in the context
to the sequences in the database. The context sequence is aligned to the sequences
in the database with sparse dynamic programming, then the regions include the
positions of interest are identified. A wavefront alignment is performed to pin
down the exact mapped positions in the sequences in the database.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>list</em><em> of </em><em>integer</em>) – a list of integers of the position to map</p></li>
<li><p><strong>seq</strong> (<em>list</em><em> of </em><em>bytes</em>) – a list of bytes representing the DNA sequence providing to context</p></li>
<li><p><strong>penalty</strong> (<em>float</em>) – the gap penalty factor used in sparse dynamic programming for finding the hits</p></li>
<li><p><strong>merge_range_tol</strong> (<em>int</em>) – a parameter used to merge the alignment ranges</p></li>
<li><p><strong>max_count</strong> (<em>int</em>) – only use the shimmer pairs that less than the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> for sparse dynamic programming</p></li>
<li><p><strong>max_query_count</strong> (<em>int</em>) – only use the shimmer pairs that less than the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> in the query sequence for sparse dynamic programming</p></li>
<li><p><strong>max_query_count</strong> – only use the shimmer pairs that less than the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> in the target sequence for sparse dynamic programming</p></li>
<li><p><strong>max_aln_span</strong> (<em>int</em>) – the size of span used in the sparse dynamic alignment for finding the hits</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>a list of tuples of
(<code class="docutils literal notranslate"><span class="pre">position_in_the_context</span></code>,
(<code class="docutils literal notranslate"><span class="pre">target_seq_id</span></code>, <code class="docutils literal notranslate"><span class="pre">target_position</span></code>, <code class="docutils literal notranslate"><span class="pre">orientation</span></code>),
(<code class="docutils literal notranslate"><span class="pre">context_end</span></code>, <code class="docutils literal notranslate"><span class="pre">context_end</span></code>),
(<code class="docutils literal notranslate"><span class="pre">target_end</span></code>, <code class="docutils literal notranslate"><span class="pre">target_end</span></code>))</p>
<p>the sequences from (<code class="docutils literal notranslate"><span class="pre">context_end</span></code>, <code class="docutils literal notranslate"><span class="pre">context_end</span></code>) in the context sequence and
the sequences from (<code class="docutils literal notranslate"><span class="pre">target_end</span></code>, <code class="docutils literal notranslate"><span class="pre">target_end</span></code>) in the target sequence are
used for the detailed alignment to pin down the exact mapped positions.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.query_fragment">
<span class="sig-name descname"><span class="pre">query_fragment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.query_fragment" title="Permalink to this definition">¶</a></dt>
<dd><p>use a fragment of sequence to query the database to get all hits</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seq</strong> (<em>list</em>) – the sequence in bytes used for query</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl>
<dt>a list of hits in the format (shimmer_pair, query_fragment, target_fragments), where</dt><dd><ul>
<li><p>shimmer_pair: (int, int), tuple of the shimmer_pair</p></li>
<li><p>query_fragment: (int, int, int) = (start_coordinate, end_coordinate, orientation)</p></li>
<li><p>target_fragments: a list of <code class="docutils literal notranslate"><span class="pre">FragmentSignature</span></code>: (frg_id, seq_id, bgn, end,
orientation(to the shimmer pair)) defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pub</span> <span class="nb">type</span> <span class="n">FragmentSignature</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.query_fragment_to_hps">
<span class="sig-name descname"><span class="pre">query_fragment_to_hps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">penalty</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_query_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_target_count</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_aln_span</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.query_fragment_to_hps" title="Permalink to this definition">¶</a></dt>
<dd><p>use a fragment of sequence to query the database to get all hits</p>
<p>sparse dynamic programming is performed to long chain of alignment</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq</strong> (<em>list</em><em> of </em><em>bytes</em>) – a list of bytes representing the DNA sequence</p></li>
<li><p><strong>penalty</strong> (<em>float</em>) – the gap penalty factor used in sparse dynamic programming for finding the hits</p></li>
<li><p><strong>merge_range_tol</strong> (<em>int</em>) – a parameter used to merge the alignment ranges</p></li>
<li><p><strong>max_count</strong> (<em>int</em>) – only use the shimmer pairs that less than the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> for sparse dynamic programming</p></li>
<li><p><strong>max_query_count</strong> (<em>int</em>) – only use the shimmer pairs that less than the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> in the query sequence for sparse dynamic programming</p></li>
<li><p><strong>max_query_count</strong> – only use the shimmer pairs that less than the <code class="docutils literal notranslate"><span class="pre">max_count</span></code> in the target sequence for sparse dynamic programming</p></li>
<li><p><strong>max_aln_span</strong> (<em>int</em>) – the size of span used in the sparse dynamic alignment for finding the hits</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of tuples of
(<code class="docutils literal notranslate"><span class="pre">target_sequence_id</span></code>, (<code class="docutils literal notranslate"><span class="pre">score</span></code>, <code class="docutils literal notranslate"><span class="pre">list_of_the_hit_pairs</span></code>)), where
the <code class="docutils literal notranslate"><span class="pre">list_of_the_hit_pairs</span></code> is a list of tuples of
((<code class="docutils literal notranslate"><span class="pre">query_start</span></code>, <code class="docutils literal notranslate"><span class="pre">query_end</span></code>, <code class="docutils literal notranslate"><span class="pre">query_orientation</span></code>),
(<code class="docutils literal notranslate"><span class="pre">target_start</span></code>, <code class="docutils literal notranslate"><span class="pre">target_end</span></code>, <code class="docutils literal notranslate"><span class="pre">target_orientation</span></code>))</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.seq_index">
<span class="sig-name descname"><span class="pre">seq_index</span></span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.seq_index" title="Permalink to this definition">¶</a></dt>
<dd><p>get a dictionary that maps (ctg_name, source) -&gt; (id, len)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.seq_info">
<span class="sig-name descname"><span class="pre">seq_info</span></span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.seq_info" title="Permalink to this definition">¶</a></dt>
<dd><p>a dictionary that maps id -&gt; (ctg_name, source, len)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.shmmr_sparse_aln_consensus">
<span class="sig-name descname"><span class="pre">shmmr_sparse_aln_consensus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_cov</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.shmmr_sparse_aln_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>generate consensus sequence for one sequence in the database</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.sort_adj_list_by_weighted_dfs">
<span class="sig-name descname"><span class="pre">sort_adj_list_by_weighted_dfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adj_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.sort_adj_list_by_weighted_dfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the adjacent list of the shimmer graph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adj_list</strong> (<em>list</em>) – the list from the output from <code class="docutils literal notranslate"><span class="pre">get_smp_adj_list</span></code></p></li>
<li><p><strong>sort_by</strong> (<em>(</em><em>u64</em><em>, </em><em>u64</em><em>)</em>) – the starting node signature</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of node in the tuple (node, parent_node, node_weight, is_leaf, global_rank, branch, branch_rank)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.write_frag_and_index_files">
<span class="sig-name descname"><span class="pre">write_frag_and_index_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_prefix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.write_frag_and_index_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.write_mapg_idx">
<span class="sig-name descname"><span class="pre">write_mapg_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.write_mapg_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Write additional meta data for GFA into a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filepath</strong> (<em>string</em>) – the path to the output file</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The data is written into the file at filepath</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pgrtk.pgrtk.SeqIndexDB.write_midx_to_text_file">
<span class="sig-name descname"><span class="pre">write_midx_to_text_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filepath</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.SeqIndexDB.write_midx_to_text_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.pgrtk.get_shmmr_dots">
<span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">get_shmmr_dots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.get_shmmr_dots" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of shimmer matches for creating a dot plot between two sequences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq0</strong> (<em>list</em>) – a list of bytes representing the first sequences</p></li>
<li><p><strong>seq1</strong> (<em>list</em>) – a list of bytes representing the second sequences</p></li>
<li><p><strong>w</strong> (<em>int</em>) – window size, default to 80, max allowed is 128</p></li>
<li><p><strong>k</strong> (<em>int</em>) – k-mer size, default to 56, max allowed is 56</p></li>
<li><p><strong>r</strong> (<em>int</em>) – reduction factor for generate sparse hierarchical minimizers (shimmer),
default to 4, max allowed is 12</p></li>
<li><p><strong>min_span</strong> (<em>int</em>) – <ul>
<li><p>a parameter to remove close-by shimmer pairs</p></li>
<li><p>if not zero, shimmer pairs which the distance between them are less
than <code class="docutils literal notranslate"><span class="pre">the</span> <span class="pre">min_span</span></code> will be removed</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code>: the matched shimmer positions in sequence 0</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code>: the matched shimmer positions in sequence 1</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of two lists</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.pgrtk.get_shmmr_pairs_from_seq">
<span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">get_shmmr_pairs_from_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.get_shmmr_pairs_from_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of shimmer pair from a sequence</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w</strong> (<em>int</em>) – window size, default to 80, max allowed is 128</p></li>
<li><p><strong>k</strong> (<em>int</em>) – k-mer size, default to 56, max allowed is 56</p></li>
<li><p><strong>r</strong> (<em>int</em>) – reduction factor for generate sparse hierarchical minimizers (shimmer),
default to 4, max allowed is 12</p></li>
<li><p><strong>min_span</strong> (<em>int</em>) – <ul>
<li><p>a parameter to remove close-by shimmer pairs</p></li>
<li><p>if not zero, shimmer pairs which the distance between them are less
than <code class="docutils literal notranslate"><span class="pre">the</span> <span class="pre">min_span</span></code> will be removed</p></li>
<li><p>default to 16</p></li>
</ul>
</p></li>
<li><p><strong>padding</strong> (<em>bool</em>) – <ul>
<li><p>for short fragment that segmented by using shimmer, set <code class="docutils literal notranslate"><span class="pre">padding</span></code> to true
to preserve the first and last shimmers</p></li>
<li><p>default to false</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list fo tuple of <code class="docutils literal notranslate"><span class="pre">(shmmr0,</span> <span class="pre">shmmr1,</span> <span class="pre">position0,</span> <span class="pre">position1,</span> <span class="pre">orientation)</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.pgrtk.guided_shmmr_dbg_consensus">
<span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">guided_shmmr_dbg_consensus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.guided_shmmr_dbg_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a guided shimmer de Bruijn graph consensus</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aln_segs</strong> (<em>list</em>) – a list of the list of bytes representing the bases of each sequence</p></li>
<li><p><strong>k</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>w</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>r</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>min_span</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>min_cov</strong> (<em>int</em>) – to keep hyplotype specific consensus, if a kmer has coverage more or equal to min_cov, it will be kept</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of a set of bytes representing the consensus sequences of all branches in the graph</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.pgrtk.naive_dbg_consensus">
<span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">naive_dbg_consensus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmer_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.naive_dbg_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the CIGAR string from two sequences with WFA</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq0</strong> (<em>string</em>) – a string representing the first sequence</p></li>
<li><p><strong>seq1</strong> (<em>string</em>) – a string representing the second sequence</p></li>
<li><p><strong>ref_id</strong> (<em>int</em>) – a integer id for the reference sequence</p></li>
<li><p><strong>ref_seq</strong> (<em>string</em>) – a python string of the reference sequence</p></li>
<li><p><strong>tgt_id</strong> (<em>int</em>) – a integer id for the target sequence</p></li>
<li><p><strong>tgt_seq</strong> (<em>string</em>) – a python string of the target sequence</p></li>
<li><p><strong>aln_segs</strong> (<em>list</em>) – a list of the <code class="docutils literal notranslate"><span class="pre">AlnSegment</span></code></p></li>
<li><p><strong>s0</strong> (<em>string</em>) – a python string of the reference sequence</p></li>
<li><p><strong>s1</strong> (<em>int</em>) – a integer id for the target sequence</p></li>
<li><p><strong>aln_segs</strong> – a list of the list of bytes representing the bases of each sequence</p></li>
<li><p><strong>kmer_size</strong> (<em>int</em>) – the size of kmers used for constructing the de Bruijn graph</p></li>
<li><p><strong>min_cov</strong> (<em>int</em>) – to keep haplotype specific consensus, if a kmer has coverage more or equal to min_cov, it will be kept</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>tuple</em> – tuple of (alignment_score, CIGAR_list)</p></li>
<li><p><em>Get alignment segments from two sequences</em></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul>
<li><p><em>list</em> – a list of <code class="docutils literal notranslate"><span class="pre">AlnSegment</span></code></p>
<p>the <code class="docutils literal notranslate"><span class="pre">AlnSegment</span></code> is a Rust struct defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pub</span> <span class="n">struct</span> <span class="n">SeqLocus</span> <span class="p">{</span>
    <span class="n">pub</span> <span class="nb">id</span><span class="p">:</span> <span class="n">u32</span><span class="p">,</span>
    <span class="n">pub</span> <span class="n">bgn</span><span class="p">:</span> <span class="n">u32</span><span class="p">,</span>
    <span class="n">pub</span> <span class="nb">len</span><span class="p">:</span> <span class="n">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">pub</span> <span class="n">enum</span> <span class="n">AlnSegType</span> <span class="p">{</span>
    <span class="n">Match</span><span class="p">,</span>
    <span class="n">Mismatch</span><span class="p">,</span>
    <span class="n">Insertion</span><span class="p">,</span>
    <span class="n">Deletion</span><span class="p">,</span>
    <span class="n">Unspecified</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">pub</span> <span class="n">struct</span> <span class="n">AlnSegment</span> <span class="p">{</span>
    <span class="n">pub</span> <span class="n">ref_loc</span><span class="p">:</span> <span class="n">SeqLocus</span><span class="p">,</span>
    <span class="n">pub</span> <span class="n">tgt_loc</span><span class="p">:</span> <span class="n">SeqLocus</span><span class="p">,</span>
    <span class="n">pub</span> <span class="n">t</span><span class="p">:</span> <span class="n">AlnSegType</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p><em>Get alignment map from a list of alignment segments</em></p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>list</em> – a list of <code class="docutils literal notranslate"><span class="pre">AlnSegment</span></code></p></li>
<li><p><em>Perform a naive de Bruijn graph consensus</em></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of bytes representing the consensus sequence</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.pgrtk.pgr_lib_version">
<span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">pgr_lib_version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.pgr_lib_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the revision (git-hashtag) of the build</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.pgrtk.shmmr_dbg_consensus">
<span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">shmmr_dbg_consensus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.shmmr_dbg_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a shimmer de Bruijn graph consensus</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aln_segs</strong> (<em>list</em>) – a list of the list of bytes representing the bases of each sequence</p></li>
<li><p><strong>k</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>w</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>r</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>min_span</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of a set of bytes representing the consensus sequences of all branches in the graph</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.pgrtk.shmmr_sparse_aln_consensus">
<span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">shmmr_sparse_aln_consensus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_span</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_cov</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Ellipsis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.shmmr_sparse_aln_consensus" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a shimmer de Bruijn graph consensus</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aln_segs</strong> (<em>list</em>) – a list of the list of bytes representing the bases of each sequence</p></li>
<li><p><strong>k</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>w</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>r</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
<li><p><strong>min_span</strong> (<em>int</em>) – specification of the shimmers for construting graph</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of a set of bytes representing the consensus sequences of all branches in the graph</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pgrtk.pgrtk.sparse_aln">
<span class="sig-prename descclassname"><span class="pre">pgrtk.pgrtk.</span></span><span class="sig-name descname"><span class="pre">sparse_aln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sp_hits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_span</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">penalty</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pgrtk.pgrtk.sparse_aln" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sparse dynamic programming to identify alignment between sequence
using matched shimmer pairs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sp_hits</strong> (<em>list</em>) – a list of tuple of <code class="docutils literal notranslate"><span class="pre">HitPair</span></code> defined as
<code class="docutils literal notranslate"><span class="pre">pub</span> <span class="pre">type</span> <span class="pre">HitPair</span> <span class="pre">=</span> <span class="pre">((u32,</span> <span class="pre">u32,</span> <span class="pre">u8),</span> <span class="pre">(u32,</span> <span class="pre">u32,</span> <span class="pre">u8))</span></code>
This represents the hits as the position of matched Shimmer Pairs from
the two sequence. For example, if there two shimmers at position 2342
and 4322 of the query sequence that matches the shimmers at positions
6125465 and 6127445, them the HitPair will be <code class="docutils literal notranslate"><span class="pre">(2342,</span> <span class="pre">4322,</span> <span class="pre">0)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(6125465,</span> <span class="pre">6127445,</span> <span class="pre">0)</span></code>. The third number would be 1 if shimmer paired
are reversed matched to the sequence orientation and 0 otherwise.</p></li>
<li><p><strong>max_span</strong> (<em>int</em>) – For a give hit, the max_span defines how many other following hits are
considered for the next aligned position. This will limit the search
space for the best alignment. If the two sequences are very repetitive,
then one needs to use larger <code class="docutils literal notranslate"><span class="pre">max_span</span></code> to ensure capturing the right
alignment path</p></li>
<li><p><strong>penalty</strong> (<em>float</em>) – this parameter will determine when to break the alignment if there are big
gaps between the alignment segment. One can set it to zero to catch large
chunk alignment ignoring the gaps. Typically, a number between 0.1 to 0.5 should
be used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pgr-tk</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">PGR-TK</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-contents">Module contents</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to PGR-TK’s documentation!</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022+, GeneDX LLC.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/pgrtk.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>