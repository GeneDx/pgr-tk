const VERSION_STRING: &str = env!("VERSION_STRING");
use clap::{self, CommandFactory, Parser};
use rustc_hash::FxHashMap;
use std::{
    fs::File,
    io::{BufRead, BufReader, BufWriter, Write},
    path,
};
use svg::node::{self, element, Node};
use svg::Document;

/// Generate SVG from a principal bundle bed file
#[derive(Parser, Debug)]
#[clap(name = "pgr-pbundle-bed2svg")]
#[clap(author, version)]
#[clap(about, long_about = None)]
struct CmdOptions {
    /// the path to the pricipal bundle bed file
    bed_file_path: String,
    /// the prefix of the output file
    output_prefix: String,
    /// the prefix of the dendrogram file generated by pgr-pbundle-bed2dist
    #[clap(long)]
    ddg_file: Option<String>,
    /// the path the annotation files
    #[clap(long)]
    annotations: Option<String>,
    /// the path the annotation track file
    #[clap(long)]
    annotation_region_bedfile: Option<String>,
    /// the path the annotation track file
    #[clap(long)]
    offsets: Option<String>,
    /// the track range in base pair count
    #[clap(long)]
    track_range: Option<usize>,
    /// the track tick interval
    #[clap(long)]
    track_tick_interval: Option<usize>,
    /// the track panel size in pixel
    #[clap(long, default_value_t = 1600)]
    track_panel_width: usize,
    /// the factor to increase height of each track
    #[clap(long, default_value_t = 1.0)]
    track_scaling: f32,
    /// the left padding in pixel
    #[clap(long)]
    left_padding: Option<usize>,
    /// the stroke boundary width
    #[clap(long, default_value_t = 0.5)]
    stroke_width: f32,
    /// the stroke with for the annotation track
    #[clap(long, default_value_t = 2.5)]
    annotation_region_stroke_width: f32,
    /// the anotation panel width
    #[clap(long, default_value_t = 500.0)]
    annotation_panel_width: f32,
    /// the factor to increase the bounder width for highlighting repeatitive bundles
    #[clap(long, default_value_t = 1.0)]
    highlight_repeats: f32,
    /// the factor to increase the bounder width for highlighting repeatitive bundles
    #[clap(long, default_value_t = false)]
    html: bool,
    /// disable tooltips
    #[clap(long, default_value_t = false)]
    no_tooltips: bool,
    /// the factor to increase the width for highlighting bundle when clicked
    #[clap(long, default_value_t = 1.5)]
    h_factor: f32,
}

static CMAP: [&str; 97] = [
    "#870098", "#00aaa5", "#3bff00", "#ec0000", "#00a2c3", "#00f400", "#ff1500", "#0092dd",
    "#00dc00", "#ff8100", "#007ddd", "#00c700", "#ffb100", "#0038dd", "#00af00", "#fcd200",
    "#0000d5", "#009a00", "#f1e700", "#0000b1", "#00a55d", "#d4f700", "#4300a2", "#00aa93",
    "#a1ff00", "#dc0000", "#00aaab", "#1dff00", "#f40000", "#009fcb", "#00ef00", "#ff2d00",
    "#008ddd", "#00d700", "#ff9900", "#0078dd", "#00c200", "#ffb900", "#0025dd", "#00aa00",
    "#f9d700", "#0000c9", "#009b13", "#efed00", "#0300aa", "#00a773", "#ccf900", "#63009e",
    "#00aa98", "#84ff00", "#e10000", "#00a7b3", "#00ff00", "#f90000", "#009bd7", "#00ea00",
    "#ff4500", "#0088dd", "#00d200", "#ffa100", "#005ddd", "#00bc00", "#ffc100", "#0013dd",
    "#00a400", "#f7dd00", "#0000c1", "#009f33", "#e8f000", "#1800a7", "#00aa88", "#c4fc00",
    "#78009b", "#00aaa0", "#67ff00", "#e60000", "#00a4bb", "#00fa00", "#fe0000", "#0098dd",
    "#00e200", "#ff5d00", "#0082dd", "#00cc00", "#ffa900", "#004bdd", "#00b400", "#ffc900",
    "#0000dd", "#009f00", "#f4e200", "#0000b9", "#00a248", "#dcf400", "#2d00a4", "#00aa8d",
    "#bcff00",
];

fn main() -> Result<(), std::io::Error> {
    CmdOptions::command().version(VERSION_STRING).get_matches();
    let args = CmdOptions::parse();

    // parsing the bed file for the aux track
    let mut annotation_region_record =
        FxHashMap::<String, Vec<(u32, u32, String, String)>>::default();
    if args.annotation_region_bedfile.is_some() {
        let bed_file_path = &args.annotation_region_bedfile.unwrap();
        let bed_file_path = path::Path::new(bed_file_path);
        let bed_file = BufReader::new(File::open(bed_file_path)?);
        let bed_file_parse_err_msg = "annotation bed file parsing error";
        bed_file.lines().into_iter().for_each(|line| {
            let line = line.unwrap().trim().to_string();
            if line.is_empty() {
                return;
            }
            if &line[0..1] == "#" {
                return;
            }
            let bed_fields = line.split('\t').collect::<Vec<&str>>();
            let ctg: String = bed_fields[0].to_string();
            let bgn: u32 = bed_fields[1].parse().expect(bed_file_parse_err_msg);
            let end: u32 = bed_fields[2].parse().expect(bed_file_parse_err_msg);
            let title = bed_fields[3].to_string();
            let color = bed_fields[4].to_string();
            let e = annotation_region_record.entry(ctg).or_default();
            e.push((bgn, end, title, color));
        });
    }

    // parsing the offset file if provided
    let mut ctg_to_offset = FxHashMap::<String, i64>::default();
    if args.offsets.is_some() {
        let offset_file_path = &args.offsets.unwrap();
        let offset_file_path = path::Path::new(offset_file_path);
        let offset_file = BufReader::new(File::open(offset_file_path)?);
        let offset_file_parse_err_msg = "offset file parsing error";
        offset_file.lines().into_iter().for_each(|line| {
            let line = line.unwrap().trim().to_string();
            if line.is_empty() {
                return;
            }
            if &line[0..1] == "#" {
                return;
            }
            let offset_fields = line.split('\t').collect::<Vec<&str>>();
            let ctg: String = offset_fields[0].to_string();
            let offset: i64 = offset_fields[1].parse().expect(offset_file_parse_err_msg);
            let e = ctg_to_offset.entry(ctg).or_default();
            *e = offset;
        });
    }

    // parsing the bundle bed file
    let mut max_range = 0_usize;
    let bed_file_path = path::Path::new(&args.bed_file_path);
    let bed_file = BufReader::new(File::open(bed_file_path)?);
    let mut ctg_data = FxHashMap::<String, Vec<_>>::default();
    let bed_file_parse_err_msg = "bed file parsing error";
    bed_file.lines().into_iter().for_each(|line| {
        let line = line.unwrap().trim().to_string();
        if line.is_empty() {
            return;
        }
        if &line[0..1] == "#" {
            return;
        }
        let bed_fields = line.split('\t').collect::<Vec<&str>>();
        let ctg: String = bed_fields[0].to_string();
        let bgn: u32 = bed_fields[1].parse().expect(bed_file_parse_err_msg);
        let end: u32 = bed_fields[2].parse().expect(bed_file_parse_err_msg);
        if end as usize > max_range {
            max_range = end as usize;
        };
        let pbundle_fields = bed_fields[3].split(':').collect::<Vec<&str>>();
        let bundle_id: u32 = pbundle_fields[0].parse().expect(bed_file_parse_err_msg);
        //let bundle_v_count: u32 = pbundle_fields[1].parse().expect(bed_file_parse_err_msg);
        let bundle_dir: u32 = pbundle_fields[2].parse().expect(bed_file_parse_err_msg);
        //let bundle_v_bgn: u32 = pbundle_fields[3].parse().expect(bed_file_parse_err_msg);
        //let bundle_v_end: u32 = pbundle_fields[4].parse().expect(bed_file_parse_err_msg);
        let e = ctg_data.entry(ctg).or_default();
        e.push((bgn, end, bundle_id, bundle_dir));
    });

    // parsing the file for the annotation text on the right panel
    let mut ctg_to_annotation = FxHashMap::<String, String>::default();
    let ctg_data_vec = if args.annotations.is_some() {
        let filename = args.annotations.unwrap();
        let path = path::Path::new(&filename);
        let annotation_file = BufReader::new(File::open(path)?);
        let ctg_data_vec: Vec<_> = annotation_file
            .lines()
            .map(|line| {
                let line = line.unwrap().trim().to_string();
                if line.is_empty() {
                    return None;
                }
                if &line[0..1] == "#" {
                    return None;
                }
                let mut ctg_annotation = line.split('\t');
                let ctg = ctg_annotation
                    .next()
                    .expect("error parsing annotation file")
                    .to_string();

                let data = ctg_data.get(&ctg).unwrap().to_owned();
                let mut region_annotation = vec![];
                if annotation_region_record.contains_key(&ctg) {
                    region_annotation = annotation_region_record.get(&ctg).unwrap().clone();
                }
                if let Some(annotation) = ctg_annotation.next() {
                    ctg_to_annotation.insert(ctg.clone(), annotation.to_string());
                    //annotations.push( (ctg.clone(), annotation) );
                    Some((ctg, annotation.to_string(), data, region_annotation))
                } else {
                    ctg_to_annotation.insert(ctg.clone(), "".to_string());
                    Some((ctg, "".to_string(), data, region_annotation))
                }
            })
            .flatten()
            .collect();
        ctg_data_vec
    } else {
        let mut ctg_data_vec = ctg_data.iter().map(|(k, v)| (k, v)).collect::<Vec<_>>();
        ctg_data.keys().into_iter().for_each(|ctg| {
            ctg_to_annotation.insert(ctg.clone(), ctg.clone());
        });
        ctg_data_vec.sort();
        ctg_data_vec
            .into_iter()
            .map(|(ctg, data)| {
                let mut region_annotation = vec![];
                if annotation_region_record.contains_key(ctg) {
                    region_annotation = annotation_region_record.get(ctg).unwrap().clone();
                }
                (ctg.clone(), ctg.clone(), data.clone(), region_annotation)
            })
            .collect()
    };

    // Parsing the tree dendrogram
    // TODO: change to use proper serilization
    let mut leaves = Vec::<(usize, String)>::new();
    let mut internal_nodes = Vec::<(usize, usize, usize, usize, f32)>::new();
    let mut node_position_map = FxHashMap::<usize, (f32, f32, usize)>::default();

    let ctg_data_vec = if args.ddg_file.is_some() {
        let dendrogram_file = BufReader::new(File::open(args.ddg_file.unwrap())?);
        let mut ctg_data_vec = vec![];
        dendrogram_file.lines().into_iter().for_each(|line| {
            let line = line.expect("can't read dendrogram file");
            let fields = line.trim().split('\t').collect::<Vec<&str>>();
            let parse_err_msg = "error on parsing the dendrogram file";
            match fields[0] {
                "L" => {
                    let ctg_id = fields[1].parse::<usize>().expect(parse_err_msg);
                    let ctg = fields[2].parse::<String>().expect(parse_err_msg);
                    leaves.push((ctg_id, ctg.clone()));
                    let data = ctg_data.get(&ctg).unwrap().to_owned();
                    let mut region_annotation = vec![];
                    if annotation_region_record.contains_key(&ctg) {
                        region_annotation = annotation_region_record.get(&ctg).unwrap().clone();
                    }
                    ctg_data_vec.push((
                        ctg.clone(),
                        ctg_to_annotation
                            .get(&ctg)
                            .unwrap_or(&"".to_string())
                            .clone(),
                        data,
                        region_annotation,
                    ))
                }
                "I" => {
                    let node_id = fields[1].parse::<usize>().expect(parse_err_msg);
                    let child_node0 = fields[2].parse::<usize>().expect(parse_err_msg);
                    let child_node1 = fields[3].parse::<usize>().expect(parse_err_msg);
                    let node_size = fields[4].parse::<usize>().expect(parse_err_msg);
                    let node_height = fields[5].parse::<f32>().expect(parse_err_msg);
                    internal_nodes.push((
                        node_id,
                        child_node0,
                        child_node1,
                        node_size,
                        node_height,
                    ));
                }
                "P" => {
                    let node_id = fields[1].parse::<usize>().expect(parse_err_msg);
                    let node_position = fields[2].parse::<f32>().expect(parse_err_msg);
                    let node_height = fields[3].parse::<f32>().expect(parse_err_msg);
                    let node_size = fields[4].parse::<usize>().expect(parse_err_msg);
                    node_position_map.insert(node_id, (node_position, node_height, node_size));
                }
                _ => {}
            }
        });
        ctg_data_vec
    } else {
        ctg_data_vec
    };

    // set up the layout factors
    let left_padding = if args.left_padding.is_some() {
        args.left_padding.unwrap()
    } else {
        30
    };

    let track_range = if let Some(range) = args.track_range {
        range
    } else {
        let r = ((max_range as f32 / 10000.0).ceil() * 10000.0) as usize;
        if r < 10000 {
            10000
        } else {
            r
        }
    };

    let scaling_factor = args.track_panel_width as f32 / (track_range + 2 * left_padding) as f32;
    let left_padding = left_padding as f32;
    let stroke_width = args.stroke_width;

    let mut y_offset = 0.0_f32;
    let delta_y = if !annotation_region_record.is_empty() {
        22.0_f32 * args.track_scaling + args.annotation_region_stroke_width * 0.5
    } else {
        16.0_f32 * args.track_scaling
    };

    // generate the bundle path elements
    let mut bundle_class_styles = FxHashMap::<String, String>::default();
    #[allow(clippy::needless_collect)] // we do need to evaluate as we depend on the side effect to set y_offset right
    let ctg_with_svg_paths: Vec<(String, (Vec<element::Group>, Vec<element::Group>, element::Text))> = ctg_data_vec
        .into_iter()
        .map(|(ctg, annotation,bundle_segment, annotation_segments)| {
            let mut bundle_segment_count = FxHashMap::<u32, usize>::default();
            bundle_segment.iter().for_each(|&(_bgn, _end, bundle_id, _direction)| {
                let e = bundle_segment_count.entry(bundle_id).or_insert_with(|| 0);
                *e += 1;
            });

            let offset = *ctg_to_offset.get(&ctg).unwrap_or(&0);
            let paths: Vec<element::Group> = bundle_segment
                .into_iter()
                .map(|(bgn0, end0, bundle_id, direction)| {
                    let mut bgn = (bgn0 as i64 + offset) as f32 * scaling_factor;
                    let mut end = (end0 as i64 + offset) as f32 * scaling_factor;
                    if direction == 1 {
                        (bgn, end) = (end, bgn);
                    }

                    let arror_end = end as f32;
                    let halfwidth = 5.0 * args.track_scaling;
                    let end =
                        if direction == 0 {
                            if end as f32 - halfwidth < bgn {
                                bgn
                            } else {
                                end as f32 - halfwidth
                            }
                        } else if end as f32 + halfwidth > bgn {
                            bgn
                        } else {
                            end as f32 + halfwidth
                        };

                    let bottom0 = -halfwidth * 0.6;
                    let top0 = halfwidth * 0.6;
                    let bottom1 = -halfwidth * 0.8;
                    let top1 = halfwidth * 0.8;
                    let center = 0 as f32;

                    let bundle_class = format!("bundle_{bundle_id:05}");
                    let bundle_rep_class = format!("bundle_{bundle_id:05} repeat");

                    let bundle_color = CMAP[((bundle_id * 57) % 59) as usize];
                    let stroke_color = CMAP[93 - ((bundle_id * 31) % 47) as usize];
                    let css_string = format!(
r#".{bundle_class} {{fill:{bundle_color}; stroke:{stroke_color}; stroke-width:{stroke_width}; fill-opacity:0.5}}"#);
                    bundle_class_styles.entry(bundle_class.clone()).or_insert(css_string);

                    let bundle_class = if *bundle_segment_count.get(&bundle_id).unwrap_or(&0) > 1 && args.highlight_repeats > 1.0001 {
                        bundle_rep_class
                    } else {
                        bundle_class
                    };

                    let path_str = format!(
					"M {bgn} {bottom0} L {bgn} {top0} L {end} {top0} L {end} {top1} L {arror_end} {center} L {end} {bottom1} L {end} {bottom0} Z");
                    let mut p = element::Path::new()
                        .set("d", path_str)
                        .set("class", "bundle ".to_string() + bundle_class.as_str());
                    let mut g = element::Group::new().set("transform", format!("translate({left_padding} {y_offset})"));
                    if !args.no_tooltips { // it may be good idea to disable it for every large region visualization
                        p.append(element::Title::new().add(node::Text::new(format!("{}:{}-{}:{}", ctg, bgn0, end0, bundle_id ))));
                    };
                    g.append(p);
                    g
                })
                .collect();


            let annotation_paths: Vec<element::Group> = annotation_segments
                .into_iter()
                .map(|(bgn, end, title, color)| {
                    let bgn = (bgn as i64 + offset) as f32 * scaling_factor;
                    let end = (end as i64 + offset) as f32 * scaling_factor;

                    let stroke_color = color.as_str();
                    let y = 8.0;
                    let path_str = format!(
					"M {bgn} {y} L {end} {y}");
                    let mut p = element::Path::new()
                        .set("class", "region")
                        .set("stroke", stroke_color)
                        .set("stroke-width", args.annotation_region_stroke_width)
                        .set("d", path_str);
                    let mut g = element::Group::new().set("transform", format!("translate({left_padding} {y_offset})"));
                    if !args.no_tooltips { // it may be good idea to disable it for every large region visualization
                        let title = element::Title::new().add(node::Text::new(title.clone()));
                        p.append(title);
                    };
                    g.append(p);
                    g
                })
                .collect();


            let text = element::Text::new()
                .set("x", 20.0 + left_padding + track_range as f32 * scaling_factor)
                .set("y", y_offset + 2.0)
                .set("font-size", "10px")
                .set("font-family", "monospace")
                .add(node::Text::new(annotation));
            y_offset += delta_y;
            (ctg, (paths, annotation_paths, text))
        })
        .collect();

    let tree_width = if !internal_nodes.is_empty() {
        0.15 * args.track_panel_width as f32
    } else {
        0.0
    };

    // start to construct the SVG element
    let mut document = Document::new()
        .set(
            "viewBox",
            (
                -tree_width,
                -32,
                tree_width + args.track_panel_width as f32 + args.annotation_panel_width as f32,
                24.0 + y_offset,
            ),
        )
        .set(
            "width",
            tree_width + args.track_panel_width as f32 + args.annotation_panel_width as f32,
        )
        .set("height", 56.0 + y_offset)
        .set("preserveAspectRatio", "none")
        .set("id", "bundleViwer");

    // insert CSS
    let stroke_width_rep = stroke_width * args.highlight_repeats;
    let stroke_width_hover = stroke_width * 2.0;
    let stroke_width_hover_rep = stroke_width_rep * 2.0;
    let mut css_strings = vec![
        format!(".repeat {{stroke-width:{stroke_width_rep};}}"),
        format!(".bundle:hover {{ stroke-width:{stroke_width_hover};}}"),
        format!(".repeat:hover {{ stroke-width:{stroke_width_hover_rep};}}"),
        format!(".region {{ stroke-opacity: 0.5 }};"),
    ];
    css_strings.extend(bundle_class_styles.values().cloned());
    let h_factor = args.h_factor;
    css_strings.push(format!(
        r#"path.highlighted {{transform: scaleY({h_factor}); fill-opacity:1}}"#
    ));
    let style = element::Style::new(css_strings.join("\n")).set("type", "text/css");
    document.append(style);

    // plot the hierarchical clustering tree
    if !internal_nodes.is_empty() {
        internal_nodes.into_iter().for_each(
                | (node_id, child_node0, child_node1,_, _) | {
            let (n_pos, n_height, _) = *node_position_map.get(&node_id).unwrap();
            let (c0_pos, c0_height, _) = *node_position_map.get(&child_node0).unwrap();
            let (c1_pos, c1_height, _) = *node_position_map.get(&child_node1).unwrap();
            let _n_pos = n_pos * delta_y;
            let c0_pos = c0_pos * delta_y;
            let c1_pos = c1_pos * delta_y;
            let n_height = -0.8 * tree_width * n_height;
            let c0_height = -0.8 * tree_width * c0_height;
            let c1_height = -0.8 * tree_width * c1_height;
            let path_str = format!(
                "M {c0_height} {c0_pos} L {n_height} {c0_pos} L {n_height} {c1_pos} L {c1_height} {c1_pos}");
            let path = element::Path::new()
                    .set("fill", "none")
                    .set("stroke", "#000")
                    .set("stroke-width", "1")
                    .set("d", path_str);
            document.append(path);
        });
    }

    // plot the scale bar
    let right_end = track_range as f32 * scaling_factor + left_padding;
    let scale_path_str =
        format!("M {left_padding} -14 L {left_padding} -20 L {right_end} -20 L {right_end} -14 ");
    let scale_path = element::Path::new()
        .set("stroke", "#000")
        .set("fill", "none")
        .set("stroke-width", 1)
        .set("d", scale_path_str);
    document.append(scale_path);

    let track_tick_interval = if let Some(tick_interval) = args.track_tick_interval {
        tick_interval
    } else {
        let mut tick_interval = 1_usize;
        let mut tmp = track_range as f32;
        tmp = tmp * 0.1;
        while tmp > 1.01 {
            tick_interval *= 10;
            tmp = tmp * 0.1;
        }
        tick_interval
    };

    let mut tickx = track_tick_interval;
    loop {
        if tickx > track_range {
            break;
        }
        let x = tickx as f32 * scaling_factor + left_padding;
        let tick_path_str = format!("M {x} -16 L {x} -20");
        let tick_path = element::Path::new()
            .set("stroke", "#000")
            .set("fill", "none")
            .set("stroke-width", 1)
            .set("d", tick_path_str);
        document.append(tick_path);
        tickx += track_tick_interval;
    }

    let text = element::Text::new()
        .set(
            "x",
            20.0 + left_padding + track_range as f32 * scaling_factor,
        )
        .set("y", -14)
        .set("font-size", "10px")
        .set("font-family", "sans-serif")
        .add(node::Text::new(format!("{} bps", track_range)));
    document.append(text);

    // insert the bundle paths
    ctg_with_svg_paths
        .into_iter()
        .for_each(|(_ctg, (paths, annotation_paths, text))| {
            // println!("{}", ctg);
            document.append(text);
            paths.into_iter().for_each(|path| document.append(path));
            annotation_paths
                .into_iter()
                .for_each(|path| document.append(path));
        });

    // final output
    if args.html {
        let mut out_file = BufWriter::new(
            File::create(path::Path::new(&args.output_prefix).with_extension("html"))
                .expect("can't create the HTML output file"),
        );
        let msg = "can't write the HTML doc";
        writeln!(out_file, "<html><body>").expect(msg);
        let jscript = r#"
<script>
document.addEventListener('readystatechange', event => {
    if (event.target.readyState === "complete") {
        var bundles = document.getElementsByClassName("bundle");
        for (let i = 0; i < bundles.length; i++) {
            bundles[i].onclick = function (e) {
                // alert(e.target.classList);
                let is_highlighted = false;
                let bundle_id = "";
                for (let cidx = 0; cidx < e.target.classList.length; cidx++) {
                    if (e.target.classList[cidx] == "highlighted") {
                        is_highlighted = true;
                    }
                    if (e.target.classList[cidx].match("bundle_")) {
                        bundle_id = e.target.classList[cidx]
                    }
                };
                var bundles2 = document.getElementsByClassName(bundle_id);
                for (let j = 0; j < bundles2.length; j++) {
                    if (is_highlighted) {
                        bundles2[j].classList.remove("highlighted");
                    } else {
                        bundles2[j].classList.add("highlighted");
                    }
                }
            };
        }
    }
});
</script>
"#;
        writeln!(out_file, "{}", jscript).expect(msg);
        let mut svg_elment = BufWriter::new(Vec::new());
        svg::write(&mut svg_elment, &document).unwrap();
        writeln!(
            out_file,
            "{}",
            String::from_utf8_lossy(&svg_elment.into_inner().unwrap())
        )
        .expect(msg);
        writeln!(out_file, "</body></html>").expect(msg);
    }
    let out_path = path::Path::new(&args.output_prefix).with_extension("svg");
    svg::save(out_path, &document).unwrap();
    Ok(())
}
